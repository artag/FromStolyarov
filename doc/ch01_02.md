# Книга 1

## 1.2. Как правильно использовать компьютер

### 1.2.3. Unix/Linux на домашней машине

#### ПО

Рекомендуемые оконные менеджеры:

* IceWM
* Blackbox
* Fluxbox.
* fvwm2 - (автор использует , но не рекомендует использовать читателю)

Не рекомендуется:

* GNOME
* KDE

Рекомендуемые эмуляторы терминала:

* xterm
* konsole
* Terminal

Настройки: черный цвет фона и серые буквы. Окно должно вмещать 80 символов в ширину.
Вызов терминала по hotkey.

#### Настройка терминала в Debian LXDE

1. Hotkey

```text
Параметры -> Настроить горячие клавиши
```

Для запуска lxterminal настроил Super+Z

2. Чтобы терминал запускался на весь экран

Файл `.config/openbox/lxde-rc.xml`.
Вместо:

```xml
<applications/>
```

Добавил секцию :

```xml
<applications>
    <application name='lxterminal'>
        <maximized>yes</maximized>
    </application>
</applications>
```

Я выбрал:

* Терминал LXTerminal (в LXDE)
* Шрифт Monospace Regular 14
* Тема Solarized Light

#### ПО (продолжение)

Остальные программы: браузер (автор использует palemoon), LibreOffice, atril (pdf reader),
eog (просмотр изображений), mplayer, vlc.

Редакторы текстов:

* vim
* joe
* nano

У меня вместо:

* `atril` стоит `Okular`
* `eog` стоит `gpicview`

#### Для программирования

* Компилятор Free Pascal - `fpc` или `fp-compiler`. Интегрированную среду не ставить.
* Ассемблер NASM - `nasm`.
* Компилятор Си и Си++ - `gcc`.
* Система сборки `make`.
* Отладчик `gdb`.

### 1.2.5. Дерево каталогов. Работа с файлами

Переключение на текстовую консоль - Ctrl+Alt+F1.

Переключение в оболочку X Window - Alt-F7, Alt-F8, Alt-F9.

* `~` - домашний каталог пользователя
* `$` - работа происходит под простым пользователем
* `#` - работа происходит под root

Простой пользователь `avst`, компьютер `host`, домашний каталог:

```text
avst@host:~$
```

Пользователь зашел в подкаталог `work`:

```text
avst@host:~/work$
```

Скрытые файлы начинаются с точки.

* `pwd` - узнать путь текущего каталога

* `ls` - вывести файлы в текущем каталоге
  * `a` - увидеть все файлы, включая скрытые
  * `F` - различать файлы по типам (выделяет каталоги, файлы)
  * 'R' - рекурсивно показать каталоги
  * `l` - расширенный формат вывода

```text
ls -a
ls -aF
```

* `cd` - перейти в другой кааталог

```text
cd ..
cd /
```

`/` - корневой каталог

Команда `cd` без указания каталога делает текущим домашний каталог пользователя.

Пример. Относительные пути:

```bash
/home/vasya/photos/mars.jpg
Если текущий каталог /home/vasya/photos:    - относительное имя файла mars.jpg
Если текущий каталог /home/anya/work/progs  - относительное имя будет ../../../vasya/photos/mars.jpg
```

**Совет по именованию файлов**:

* не использовать русские буквы, пробелы, знаки препинания
* можно использовать точки, подчеркивание, минус (но не начинать с него имя файла)

#### Команды для работы с файлами

|Команда  | Описание                                                    |
|---------|-------------------------------------------------------------|
| `cp`    | копирование файла                                           |
| `mv`    | переименование или перемещение файла                        |
| `rm`    | удаление файла                                              |
| `mkdir` | создание директории                                         |
| `rmdir` | удаление директории                                         |
| `touch` | создание файла или установка нового времени модификациии    |
| `less`  | просмотр содержимого файла с пейджингом                     |

```text
cp file1.txt file2.txt      - копия файла file1.txt под именем file2.txt
rm oldfile                  - удалит файл oldfile
rm -r the_dir               - удалит каталог вместе с его содержимым
```

Пример копирования с флешки:

```text
cd Photoalbum/2015
mkdir Paris
cd Paris
mount /mnt/flash
cp /mnt/flash/dcim/* .
umount /mnt/flash
```

Пример *скрипта* `getphotos`:

```bash
#!bin/sh
DIR=Photoalbum/2015
[ "$1" = "" ] && { echo "No dir name"; exit 1; }
mkdir $DIR/$1
mount /mnt/flash
cp /mnt/flash/dcim/* $DIR/$1
umount /mnt/flash
```

Использование скрипта:

```text
./getphotos Milan
```

### 1.2.6. Команда и ее параметры

Первой идет команда, затем, через пробелы, ее аргументы.

Количество пробелов между аргументами не важно.

Последовательное выполнение команд. Разделение при помощи `;`:

```text
ls -a ; pwd ; echo abrakadabra

или так

ls -a;pwd;echo abrakadabra
```

Три способа **экранировать** символы (лишение символа его особой роли):

1. Символ косой черты (`\`)
2. Двойные кавычки (`""`)
3. Апострофы (`''`)

Пример, переименование каталога, содержащего пробелы:

```text
mv Photos\ from\ Paris Photos_from_Paris
mv 'Photos from Paris' Photos_from_Paris
mv "Photos from Paris" Photos_from_Paris
```

Пример, использование символов `'`, `"`, `\`:

```text
echo I\'m fine "I'm fine"
// Вывод: I'm fine I'm fine

echo "\"" "\\"
// Вывод: " \
```

`""` или `''` - *пустое слово*

### 1.2.7. Шаблоны имен файлов

* `?` - один произвольный символ
* `*` - произвольный набор символов (даже пустой)
* `[]` - любой символ из заданного множества
* `[!]` - любой символ кроме перечисленного из множества
* `{}` - любая последовательность из множества

Примеры шаблонов:

|Символы        | Значение                                           |
|---------------|--------------------------------------------------  |
|`*`            | все файлы в текущей диектории                      |
|`???*`         | все файлы, содержащие не менее 3 символов          |
|`???`          | все файлы ровно из 3 символов                      |
|`*.txt`        | все файлы с суффиксом `.txt`                       |
|`img_????.jpg  | файлы вида `img_2578.jpg`, `img_cool.jpg`          |

Пример применения шаблонов в командах:

```text
rm *~             - удаление всех файлов в текущей директории с окончанием ~
ls /etc/*.conf          - показ файлов с суффиксом .conf в директории /etc
cp files/* /mnt/flash   - скопирует все файлы из поддиректории files в /mnt/flash
echo *    - печать файлов в текущей директории
```

#### Заданные множества

* Шаблон `img_27[234][0123456789].jpg` соответствует

  * `img_2720.jpg`
  * `img_2721.jpg`
  * ...
  * `img_2734.jpg`
  * ...
  * `img_2749.jpg`

* Шаблон `img_27[234]?.jpg`

  * Как в предыдущем шаблоне, только 4 символ может быть любым

* Шаблон `[!_]*.c`

  * любые имена файлов с суффиксом `.c`, но не начинающиеся с `_`.

* Шаблон `*.{jpg,png,gif}`

  * все файлы текущей директории с суффиксами `.jpg`, `.png` или `.gif`

### 1.2.8. История команд и автодополнение

* `Tab` - автодополнение
* `Up`, `Down` - перемещение по предыдущим введенным командам
* `history` - показать всю историю команд
  * `history | less` - постраничный показ всей истории команд

* `!<номер_команды>` - повторить команду с номером (номер команды из `history`)
  * `!!` - повторить последнюю введенную команду
  * `!:0`, `!:1` - извлечь отдельные слова из последней команды и выполнить команду из извлеченного слова.
  * `!137:2` - извлечь третье слово из команды 137 и выполнить команду из извлеченного слова.
  * `!abc` - последняя команда, начинающаяся со слов `abc` + здесь также можно извлечь отдельные слова

* `Ctrl+C` - сбросить вводимую строку
* `Ctrl+R` - поиск по подстроке ранее введенных команд. Повторные нажатия `Ctrl+R` выводят еще более старые команды.

### 1.2.9. Управление потоком задач

* `Ctrl+D`
  * прерывание потока ввода (аналог ситуации конца файла)
  * закрытие терминала (завершение сеанса работы в терминале).

* `Ctrl+C` - сигнал **`SIGINT`** - принудительное завершение активной программы

* `Ctrl+\` - сигнал **`SIGQUIT`** - принудительное завершение активной программы. Может появиться файл вида `*.core` (его можно удалить).

* `Ctrl+Z` - приостановка вывода (приостановка "прокрутки" экрана).

* `Ctrl+Q` - продолжение вывода (продолжение "прокрутки" экрана).

**Процесс** - запущенная программа в системе.

* `ps` - список процессов, выполняющихся в настоящий момент, в конректном сеансе работы.

* `ps ax` - список всех процессов, выполняющихся в настоящий момент.

* `ps axu` - список всех процессов, выполняющихся в настоящий момент и показывает информацию о владельцах процессов.

* `top` - интерактивный обновляющийся список наиболее активных процессов.

Процессу можно отправить сигналы с заданным номером/именем.

Сигналы `SIGINT` (#2), `SIGQUIT` (#3) - почти всегда приводят к немедленному завершению процесса.

Если нет, то эти сигналы перехватил процесс - для его снятия надо послать неперехватываемый сигнал **`SIGKILL`** (#9).

* `kill` по умолчанию отправляет сигнал **`SIGTERM`** (#15), который процесс также может перехватить.

Чтобы гарантированно убить процесс:

```bash
kill -9 2763
или
kill -KILL 2763
```

где `2763` номер процесса - можно узнать через `ps ax` или `top`.

Если процесс все еще не завершился (что редкость), то он может быть:

* Процесс-зомби (неубиваеый мертвый процесс). Нестрашно (он не занимает ресурсов).
  * При `ps ax` процесс-зомби помечается буквой `Z` в столбце `STAT` и словом `defunct` в другом столбце.

* Процесс выполнил системный вызов и ОС перевела его в режим "непрерываемого сна".
Возможно, это признак неисправного оборудования (например, начал сыпаться жесткий диск).
  * При `ps ax` помечается буквой `D` в столбце `STAT`.

### 1.2.10. Выполнение в фоновом режиме

Чтобы запустить команду в фоновом режиме, к ней следует в конце приписать символ **`&`**.

Пример:

```bash
avst@host:~$ updatedb &
[1] 2437
```

`1` - номер фоновой задачи

2473 - номер запущенного процесса

* `jobs` - текущий список выполняемых фоновых задач.

  Статусы фоновой задачи:

  * `Running` - выполняется
  * `Done` - успешно завершена
  * `Exit 1` - неуспешное завершение
  * `Terminated` - фоновый процесс снят сигналом `SIGTERM`

* `kill %2` - отправит `SIGTERM` второй фоновой задаче
  * `kill %` - отправит `SIGTERM` последней фоновой задаче

#### Перевод задачи в фоновый режим и обратно

1. `Ctrl+Z` - приостановка выполнения текущей задачи

2. Команда `bg` (от background) - приостановленная задача запускается в фоновом режиме.

3. Команда `fg` (от foreground) - приостановленная задача запускается и становится текущей.

### 1.2.11. Перенаправление потоков ввода-вывода

Запущенные программы могут общаться с внешним миров через **потоки ввода-вывода**.

Программа может одновременно работатать с несколькими потоками ввода-вывода, различая их по номерам.
Эти номера называются - **дескрипторы**.

Соглашения по нумерации потоков ввода-вывода:

* `0` - поток стандартного ввода
* `1` - поток cтандартного вывода
* `2` - поток для вывода сообщений об ошибках

Примеры перенаправлений ввода-вывода (символы `<`, `>`, `>>`, `>&`, `|`):

* `cmd1 > file1`
  * запустить программу `cmd1`
  * направить ее вывод в файл `file1`, если существует будет переписан, если нет - создан

* `cmd1 >> file1`
  * запустить программу `cmd1`
  * ее вывод будет дописан в файл `file1`, если файл не сущесвет будет создан

* `cmd2 < file2`
  * запустить программу `cmd2`
  * на ее стандартный ввод подается содержимое файла `file2`, если файл не существует, то произойдет ошибка

* `cmd3 > file1 < file2`
  * запустить программу `cmd3`
  * перенаправляется и ввод, и вывод

* `cmd1 | cmd2`
  * запуск программ `cmd1` и `cmd2`
  * вывод из `cmd1` подается на вход `cmd2`

* `cmd4 2> errfile`
  * запуск программы `cmd4`
  * направить ее поток сообщений об ошибках в файл `errfile`

* `cmd5 2>&1 | cmd6`
  * запуск программы `cmd5`
  * объединить потоки вывода и диагностики и направить на стандартный ввод программы `cmd6`

* `ls -lR | less` - рекурсивно постранично показать файлы (расширенный формат вывода) в текущей директории и поддиректориях

* `gcc -Wall -g myprog.c -o myprog 2>&1 | less` - постранично показать поток вывода и диагностики из компилятора Си

* `ls -l -R / > list.txt 2> /dev/null` - сделать список всех файлов в системе, на которые хватит прав вывести
в псевдоустройство `/dev/null`, т.е. проигнорировать

  * `/dev/null` - **псевдоустройство**, все что туда направлено исчезает.

### 1.2.12. Редакторы текстов

* Редактор `Vim`. Обучающая программа `vimtutor`.

* Редактор `nano`.

* Редактор `JOE`

* Редактор оболочки `Midnight Commander`

#### Редактор `nano`

`nano <имя_файла>` - создать новый или открыть существующий файл

* `Ctrl+C` - показать текущую позицию
* `Ctrl+O` - сохранить файл
* `Ctrl+X` - выход из редактора
* `Ctrl+Shift+_` - перейти на строку,столбец (формат `<число1>,<число2>`)
* `Ctrl+K` - вырезать строку
* `Ctrl+U` - вставить вырезанную строку
* `Ctrl+G` или `F1` - справка

### 1.2.13. Права доступа к файлам

В Unix/Linux для каждого файла определены **права доступа** - 12 битное слово.

#### Права доступа. 9 младших бит (из 12)

`ls -l` показывает файлы с правами доступа (9 младших бит).

Пример:

```text
-rwxr-xr-x
```

* Первый символ
  * `-` файл
  * `d` директория

* `rwx` права доступа для владельца

* `r-x` права доступа для группы

* `r-x` права доступа для всех остальных

Права доступа:

* `r` - чтение
* `w` - запись
* `x` - исполнение
* `-` - соответствующее право отсутствует

Права доступа кодируются 3-мя числами в восьмеричной системе.

Например:

```text
-rwxr-xr-x     эквивалентно числу       0755
```

`0755` - В языке Си означает запись числа в восьмеричной системе.

#### Права доступа на каталог

* `r-x` - можно только читать содержимое каталога.

* `rwx` - можно изменять каталог. Создавать, удалять, переименовывать любые файлы в нем.

* * `r--` или `w--` пользователь не может просмотреть содержимое каталога.
  * `r--` прочитать файл из такого каталога можно, если точно указать путь к этому файлу.

* `-wx` можно создать файл в каталоге или переименовать/удалить существующий(если знаем точное имя).

#### Права доступа. 3 старших разряда (из 12)

* `SetUid Bit` `(04000)`
  * Если установить для исполняемого файла: этот файл при исполнении будет иметь права своего владельца,
  вне зависимости от пользователя, который запустил этот файл.
  * Игнорируется на каталогах в большинстве систем.

* `SetGid Bit` `(02000)`
  * Если установить для исполняемого файла: этот файл при исполнении будет иметь права группы владельца файла,
  вне зависимости от группы пользователя, который запустил этот файл.

* `Sticky Bit` `(01000)` - даже если пользователь имеет право на запись в каталог удалить он сможет только свои файлы.
  * На простых файлах современными системами игнорируется.
  * Для каталогов - какой бы пользователь ни создал в этом каталоге файл, в качестве "группы владельца" будет
  установлена та же группа, что и у каталога.

Пример `SetGid Bit` - обычно установлен для программы `passwd`.

Пример `Sticky Bit` - каталог `/tmp`.

#### Смена прав доступа

Команда **`chmod`**

Мнемоническая строка `[ugoa][+-=][rwxsXtugo]`

* `u` - владелец (user)
* `g` - группа (group)
* `o` - все остальные (others)
* `a` - все сразу (all)
* `+` - добавление новых прав
* `-` - снятие старых прав
* `=` - установка указанных прав и снятие всех остальных
* `r` - права на чтение
* `w` - права на запись
* `x` - права на исполнение
* `s` - установка/снятие `Set`-битов (имеет смысл только для владельца и группы)
* `t` - `Sticky Bit`
* `u` - права, которые установлены для владельца
* `g` - права, которые установлены для группы
* `o` - права, которые установлены для остальных
* `X` - установка/снятие бита исполнения только для каталогов и для файлов, на которые хотя бы у кого-нибудь есть право исполнения

Флаг `-R` - смена прав доступа ко всем файлам по всех поддиректориях

1. Установка прав записи на файл `myfile.c` только для владельца, права чтения - для всех

```bash
chmod 644 myfile.c            (права rw-r--r--)
```

2. Сделать файл исполняемым

```bash
chmod a+x myscript
```

3. Снимет со всех файлов все права, кроме прав владельца

```bash
chmod go-rwx *
```

4. **Полезная команда**. Установка в домашней директории и поддиректориях права для владельца на чтение и запись.
Для директорий и файлов, для которых исполнение разрешено хоть кому-то, владельцу также назначаются права на исполнение.
Для группы и остальных пользователей устанавливаются права на чтение, для исполняемых файлов и директорий - также права на исполнение, а все
остальные права убираются.

```bash
chmod -R u+rwX,go=rX ~
```

### 1.2.14. Электронная документация (команда `man`)

Команда `man <номер_секции> <команда/понятие/формат/...>`

* `q` - выход из справки

* `/`, строка для поиска, потом `Enter` - поиск. Повторный поиск, просто `/` и `Enter`

* `?` - поиск в обратном направлении (вместо `/`)

Основые номера секций (опционально, для уточнения поиска):

* `1` - пользовательские команды *nix (`ls`, `rm`, `mv`, ...)
* `2` - системные вызовы ядра *nix
* `3` - библиотечные функции Си
* `4` - описания файлов устройств
* `5` - описания форматов конфигурационных файлов
* `6` - игровые программы
* `7` - общие понятия
* `8` - команды системного администрирования *nix

Примеры:

```bash
man ls
man 2 write     документация по системному вызову write
man 7 ip        полезная информация о программированиии с использованием TCP/IP
man 8 mount
```

### 1.2.15. Командные файлы (скрипты) в Bourne Shell

Файл скрипта должен начинаться с `#!`, потом полный пусть к исполняемому файлу интерпретатора:

```bash
#!/bin/sh
```

У файла скрипта в правах доступа должен быть **`x`**

Пример скрипта [humpty.sh](/src/ch01/humpty.sh), печатающего на экране текст при помощи `echo`.

1. Создаем скрипт
2. `chmod +x humpty.sh` - Установка прав на исполнение
3. `./humpty.sh` - Запуск на исполнение

`.` - означает "текущая директория", `/` - разделитель между именем директории и именем файла.

`./humpty.sh` - запустить файл, находящийся в текущей директории.

В имени подобных запускаемых файлов должен присутствовать хотя бы один `/`, иначе система будет искать команду
с таким именем в системных каталогах (и не найдет его).

#### Bourne Shell

Переменные:

* состоят из латинских букв, цифр, знака подчеркивания
* начинаются всегда с буквы

```sh
I=10
MYFILE=/tmp/the_file_name
MYSTRING="Here are several words"
```

Обращение к переменной - используется знак `$`:

```sh
echo $I $MYFILE $MYSTRING

# напечатает:
# 10 /tmp/the_file_name Here are several words
```

Скомпоновать слитный текст из значений переменных - используется `${ }`

```sh
echo ${I}abc

# напечатает:
# 10abc
```

Арифметическое действие - используется `$(( ))`:

```sh
I=$(( $I + 7 ))
# или так
I=$(($I + 7))

# результат:
# I станет равным 17
```

Переменные вида `$0`, `$1`, ..., `$12` - аргументы командной строки

Переменная `$#` - целое число, количество аргументов

Пример [argdemo.sh](src/ch01/argdemo.sh):

```sh
#!/bin/sh
echo "My name is " $0
echo "I've got " $# " parameters"
echo "Here are the first three of them, in reverse order:"
echo "" "$3 $2 $1"
```

Если запустить его:

```bash
./argdemo.sh abra schwabra kadabra

# напечатает:

# My name is  ./argdemo.sh
# I've got  3  parameters
# Here are the first three of them, in reverse order:
#  kadabra schwabra abra
```

В **подпрограммах** `$0`, `$1`, ... это значения параметров, переданных в подпрограмму,
а $# - это их количество.

Программы в Unix/Linux при своем заверешении возвращают **код завершения** - число от 0 до 255.

`0` - код успеха, все остальные - коды ошибок.

Команда `test` или `[ ]` позволяют проверять **предположения**:

```sh
[ -f "file.txt" ]
            # существует ли файл с именем file.txt
[ "$I" -lt 25 ]
            # значение переменной I меньше 25
[ "$A" = "abc" ]
            # значение переменной A является строкой abc
[ "$A" != "abc" ]
            # значение переменной A не является строкой abc
```

Это можно использовать в инструкции **ветвления**:

```sh
if [ -f "file.txt" ]; then
    cat "file.txt"
else
    echo "File file.txt not found"
fi
```

Или так, без использования скобок:

```sh
if test -f "file.txt" ; then
    cat "file.txt"
else
    echo "File file.txt not found"
fi
```

Можно использовать не только `test`, но и другие команды:

```sh
if mkdir new_dir; then
    echo "Directory created"
else
    echo "Failed to make new directory"
fi
```

**Цикл while**. Печать всех чисел от 1 до 100:

```sh
I=1
while [ $I -le 100 ]; do
    echo $I
    I=$(( I + 1))
done
```

**Флаги**:

* `-le` - условие "меньше или равно"

* `-lt` - "строго меньше"

* `-gt` - "строго больше

* `-ge` - "больше или равно"

**Цикл for**. Печать в столбик все названия цветов радуги:

```sh
for C in red orange yellow green blue indigo violet; do
    echo $C
done
```

#### Логические связки `&&` `||`

Имеют одинаковый приоритет.

Выполнение команды `cmd2`, если `cmd1` *успешно* завершилась:

```bash
cmd1 && cmd2
```

Выполнение команды `cmd2`, если `cmd1` *неуспешно* завершилась:

```bash
cmd1 || cmd2
```

Приоритет операции "конвейер" `|` и перенправоенный ввод-вывод больше, чем у `&&` и `||`.

Значение "истинности" конвейера определяется успешностью или неуспешностью выполнения последней
составляющей из его команд:

```bash
cmd1 && cmd2 | cmd3
```

Стандартный ввод-вывод команд `cmd1` и `cmd2` будет направлен на стандартный ввод `cmd3`:

```bash
(cmd1 && cmd2) | cmd3
```

### 1.2.16. Переменные окружения

Это множество текстовых строк вида

```text
VAR=VALUE
```

* `VAR` - имя переменной
* `VALUE` -ее значение

У каждого процесса свои переменные окружения. Порожденный процесс наследует окружение процесса-родителя.

Основные переменные окружения:

* `PATH` - список каталогов для поиска запускаемой команды/файла

* `HOME` - путь к домашнему каталогу

* `LANG` - язык в ОС

* `EDITOR` - редактор текстов по умолчанию

Команда **`env`** - показывает все текущие переменные окружения.

**Обращение** к переменным окружения:

```bash
echo $PATH
echo $HOME
echo $LANG
```

**Изменить** переменную окружения скопировать обратно в окружение (применить) - при помощи `export`:

```bash
PATH=$PATH:/sbin:/usr/sbin
export PATH

# или так
export PATH=$PATH:/sbin:/usr/sbin
```

**Удалить** переменную окружения:

```bash
unset MYVAR
```

Запустить команду с окружением, измененным для нее одной:

```bash
VAR=value command
```

Например, сменить информацию только для текущего пользователе (команда `chfn`),
задав редактор по умолчанию только для него:

```bash
EDITOR=nano chfn
```

### 1.2.17. Протоколирование сеанса работы

Команда `script`. Протоколирует сеанс работы.

Запуск:  `script my_protocol.txt`

Окончание протоколирования: `Ctrl+D`

### 1.2.18. Графическая подсистема в ОС Unix/Linux

X Window System - программный комплекс для поддержки графического режима работы.

X-сервер - программа, отвечающая за отображение информации на дисплее.

X-клиенты - программы, обращающиеся к X-серверу с запросами на вывод изображения.

`xterm` - пример X-клиента, эмулятор терминала.

#### Запуск X Window

Запуск X Window - команда `startx`, которая "под капотом" запускает `xinit`.

Подключение к удаленному xdm-серверу - команда `X -broadcast`

Файл `~/.xinitrc` - настройки для запуска `startx`. Пример файла `.xinitrc`:

```sh
xterm &
twm
```

Файл `~/.xsession` - настройки сеанса работы, настройки окружения.

Рекомендуемое содержимое файла `.xsession`:

```sh
. ~/.profile
. ~/.xinitrc
```

* `.profile` - описание рабочего окружения
* `.xinitrc` - настройки запуска
